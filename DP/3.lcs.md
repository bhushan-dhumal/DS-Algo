


![lcs_problems_list](https://user-images.githubusercontent.com/10953202/149148813-bcb3030f-f8d5-42aa-acd9-f3c1c03d848c.jpg)

## Longest Common Subsequence 

[GFG Link](https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/)

[GFG Practice](https://practice.geeksforgeeks.org/problems/longest-common-subsequence-1587115620/1)
### Recursive
Below solution tried on GFG practice.
Solution gave current output for two examples given but not accepted as it is taking more time.
``` c++
class Solution
{
    public:
    //Function to find the length of longest common subsequence in two strings.
    int lcs(int x, int y, string s1, string s2)
    {
        // your code here
        if(x == 0 || y == 0)
            return 0;
        if(s1[x-1] == s2[y-1])
            return 1+lcs(x-1,y-1,s1,s2);
        return max(lcs(x,y-1,s1,s2),lcs(x-1,y,s1,s2));
    }
};

```


### Top-Down (Memoization)
``` c++
class Solution
{
    int arr[1000][1000]; // max possible size of both strings
    string s1;
    string s2;
    public:
    int lcs(int x, int y, string s1, string s2)
    {
        // your code here
        this->s1 = s1;
        this->s2 = s2;
        memset(arr, -1, sizeof arr); 
        return lcs(x,y);

    }
    
    int lcs(int x, int y)
    {
        if(x == 0 || y == 0)
            return 0;
        if(arr[x][y]!=-1)
            return arr[x][y];
        if(s1[x-1] == s2[y-1])
        {
            arr[x][y] = 1+lcs(x-1,y-1);
            return arr[x][y];
        }
        arr[x][y] = max(lcs(x,y-1),lcs(x-1,y));
        return arr[x][y];
        
        
    }
};
```
### Bottom-Up (Tabular)
``` c++
class Solution
{
    public:
    int lcs(int x, int y, string s1, string s2)
    {
        int n = s1.size();
        int m = s2.size();
        vector<vector<int>> vec(n+1,vector<int>(m+1,-1));
        for(int i =0; i <=n;i++)
        {
            for(int j =0; j <=m;j++)
            {
                if(i ==0 || j ==0)
                {
                    vec[i][j] = 0;
                }
                else if(s1[i-1] == s2[j-1])
                {
                    vec[i][j] = 1+vec[i-1][j-1];
                }
                else
                {
                    vec[i][j] = max(vec[i][j-1],vec[i-1][j]);
                }
            }
        }
        return vec[n][m];
    }
    
};
```
## Longest Common Substring

[GFG Link](https://www.geeksforgeeks.org/longest-common-substring-dp-29/) [GFG Practice](https://practice.geeksforgeeks.org/problems/longest-common-substring1452/1/)

### Bottom-Up (Tabular)
``` c++
class Solution{
    public:
    
    int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        // your code here
        vector<vector<int>> vec(n+1,vector<int>(m+1,-1));
        int mx = INT_MIN;
        for(int i =0;i<=n;i++)
        {
            for(int j =0;j<=m;j++)
            {
                if(i==0 || j==0)
                {
                    vec[i][j] = 0;
                }
                else if(S1[i-1] == S2[j-1])
                {
                    vec[i][j]=1+vec[i-1][j-1];
                }
                else
                {
                    vec[i][j] = 0;
                }
                mx=max(mx,vec[i][j]);
            }
        }
        return mx;
    }
};
```
One thing to note is that at last we have to return the max value in the matrix and not vec[m][n]. Why it is so? Cause substring can exist anywhere in between. Just think a bit about it bit and you will understand.
